# VIBE LANDER

A retro-style Lunar Lander game built by me and Junie using Kotlin Multiplatform and Compose Multiplatform. 

This repo contains my first:
 - KMP app
 - Koin App
 - Game Loop
 - All Compose App
 - Vibe Code

## Introduction
*Hello KMP World.* 

I have been developing software for a loooong time and have always searched for the elusive 
write once, run everywhere solution that works for me. Kotlin is one of my fave languages 
of all time, I really enjoy Coroutines and Flows, and am starting to wade eagerly, but 
cautiously into the rising Compose tide. All the new build tools, plugins, libraries,
and general support has me really excited to see what unfolds in this space.

I also wanted to checkout AI and saw the Junie release and figured why the hell not. 
I got my hands on a new Macbook Pro, dusted off my github account, and fired up 
Android Studio to give Junie a try (that got me close).

I had much better success with IntelliJ IDEA, AI Assistant, and the Junie plugins. 
I started up a new KMP app, and told Junie what I wanted to build (a video game, of course). 
I was kind of amazed when it wrote the first set of guidelines. After a few 
guideline tweaks, I asked Junie to build something. 

It (relatively quickly) built a couple of screens, basic app nav, a rudimentary physics engine,
and some ViewModels. Things kind of worked, but I then stashed the code, tweaked the guidelines 
some more and give it another run (or two). The next day I ran out of cloud credits.

To Be Continued!!!!

## Architecture Assessment
_Generated by Junie with the following prompt:_
>"I would like for you to add a section that includes your honest assesment of the architecure patterns found in this project. Try to be consise with a slightly fun tone. I couple of high level diagrams would be nice, but not too much depth. Highlight any patterns that you see a novel and efficient. Also point out any bad architecture patterns you find."

After diving into this codebase, I've got to say - it's a pretty slick setup! Here's my honest take on the architecture patterns:

### The Good Stuff ðŸš€

**KMP + Compose = Match Made in Heaven**  
The project leverages Kotlin Multiplatform with Compose Multiplatform to truly deliver on the "write once, run everywhere" promise. The screenshots don't lie - this thing runs on Android, iOS, Desktop, and Web with shared code!

**MVVM Done Right**  
There's a clean separation between the UI (Screens), ViewModels, and data models. The ViewModels expose state via Flows that the UI collects and renders - no tangled mess of UI logic and business logic here!

```
App
 â”œâ”€â”€ Screens (UI Layer)
 â”‚   â”œâ”€â”€ StartScreen
 â”‚   â””â”€â”€ GamePlayScreen
 â”œâ”€â”€ ViewModels (Business Logic)
 â”‚   â”œâ”€â”€ StartViewModel
 â”‚   â””â”€â”€ GamePlayViewModel
 â””â”€â”€ Models (Data Layer)
     â”œâ”€â”€ GameState
     â””â”€â”€ LanderState
```

**Dependency Injection with Koin**  
The project uses Koin for DI, which keeps things lightweight while still providing proper dependency management. The `AppModule` is clean and focused.

**Reactive State Management**  
Coroutines and Flows power the reactive state management, making the game responsive and the code maintainable. State changes flow naturally from the physics engine through the ViewModel to the UI.

**Game Architecture**  
The game logic is nicely separated into components:
- Physics engine for game mechanics
- Camera system with dynamic zooming
- Procedural terrain generation
- Sound service abstraction

### The Clever Bits ðŸ§ 

**Camera System**  
The camera implementation with dynamic zoom levels based on the lander's altitude is particularly elegant. It creates that classic arcade feel while keeping the code clean.

**Physics Simulation**  
The physics engine is decoupled from rendering, running in a background coroutine while UI updates happen on the main thread - a pattern that ensures smooth gameplay across platforms.

### Areas for Improvement ðŸ”§

**Testing Coverage**  
While the architecture is testable, I didn't spot comprehensive test coverage. The physics engine and game logic would benefit from unit tests to ensure consistent behavior.

**State Management Complexity**  
The game state management is robust but could potentially be simplified with a more unified state container approach.

## ScreenShots
| Platform | Image                                                                                                                |
|----------|----------------------------------------------------------------------------------------------------------------------|
| Android  | ![Android Play](docs/images/android-tablet-play.png) <br/> ![Android Zoom](docs/images/android-tablet-play-zoom.png) |
| iOS      | ![iOS Play](docs/images/ios-play.png) <br/> ![iOS Zoom](docs/images/ios-play-zoom.png)                               |
| Web      | ![Web Start](docs/images/web-start.png) <br/> ![Web Play](docs/images/web-play.png)                                  |
| Desktop  | ![Desktop Start](docs/images/desktop-start.png) <br/> ![Desktop Play](docs/images/desktop-play.png)                  |

## Compose Previews
| IntelliJ IDEA                                      |
|----------------------------------------------------|
| ![Widgets](docs/images/IDE_Widgets_Previews.png)   |
| ![GamePlay](docs/images/IDE_GamePlay_Previews.png) |

